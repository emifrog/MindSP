generator client {
  provider = "prisma-client-js"
  previewFeatures = ["fullTextSearch"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ================================
// CORE MODELS
// ================================

model Tenant {
  id          String   @id @default(uuid())
  slug        String   @unique // sdis13, sdis06
  name        String
  domain      String   @unique // sdis13.mindsp.fr
  status      TenantStatus @default(ACTIVE)
  
  // Configuration
  config      Json?    // Settings flexibles
  logo        String?
  primaryColor String? @default("#1e40af")
  
  // Metadata
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  users       User[]
  fmpas       FMPA[]
  messages    Message[]
  conversations Conversation[]
  formations  Formation[]
  events      Event[]
  documents   Document[]
  notifications Notification[]
  availabilities Availability[]
  calendarEvents CalendarEvent[]
  formationRegistrations FormationRegistration[]
  ttaEntries TTAEntry[]
  ttaExports TTAExport[]
  portals     Portal[]
  newsArticles NewsArticle[]
  portalDocuments PortalDocument[]
  chatChannels ChatChannel[]
  mailMessages MailMessage[]
  agendaEvents AgendaEvent[] @relation("AgendaEvents")
  mailingLists MailingList[] @relation("MailingLists")
  
  @@index([slug])
  @@index([domain])
  @@map("tenants")
}

enum TenantStatus {
  ACTIVE
  SUSPENDED
  TRIAL
  CANCELLED
}

model User {
  id            String    @id @default(uuid())
  tenantId      String
  
  // Authentication
  email         String
  passwordHash  String
  emailVerified DateTime?
  
  // Profile
  firstName     String
  lastName      String
  phone         String?
  avatar        String?
  badge         String?    // Matricule
  
  // Role & Permissions
  role          UserRole   @default(USER)
  permissions   String[]   // Array of permission codes
  
  // Status
  status        UserStatus @default(ACTIVE)
  lastLoginAt   DateTime?
  
  // Refresh Tokens
  refreshTokens RefreshToken[]
  
  // Metadata
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  // Relations
  tenant        Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  
  // FMPA
  fmpasCreated  FMPA[]    @relation("FMPACreator")
  participations Participation[]
  
  // Messaging
  sentMessages  Message[] @relation("MessageSender")
  conversationMembers ConversationMember[]
  messageReads  MessageRead[] @relation("MessageReads")
  
  // Formations
  formationsCreated Formation[] @relation("FormationCreator")
  formationsInstructed Formation[] @relation("FormationInstructor")
  formationRegistrations FormationRegistration[]
  formationValidations FormationRegistration[] @relation("FormationValidator")
  
  // Events
  eventsCreated Event[]   @relation("EventCreator")
  eventParticipations EventParticipation[]
  
  // Notifications
  notifications Notification[]
  
  // Agenda / Calendrier
  availabilities Availability[]
  calendarEventsCreated CalendarEvent[] @relation("EventCreator")
  calendarEventParticipations EventParticipant[]
  
  // TTA
  ttaEntries TTAEntry[]
  ttaValidations TTAEntry[] @relation("TTAValidator")
  ttaExportsCreated TTAExport[]
  
  // Portails & CMS
  newsArticles NewsArticle[] @relation("NewsAuthor")
  portalDocuments PortalDocument[] @relation("PortalDocumentUploader")
  
  // Chat Temps Réel
  chatChannelsCreated ChatChannel[] @relation("ChannelCreator")
  chatMemberships ChatChannelMember[] @relation("ChatMemberships")
  chatMessages ChatMessage[] @relation("ChatMessages")
  chatReactions ChatReaction[] @relation("ChatReactions")
  chatMentions ChatMention[] @relation("ChatMentions")
  presence UserPresence?
  
  // Mailbox
  sentMails MailMessage[] @relation("SentMails")
  receivedMails MailRecipient[] @relation("ReceivedMails")
  mailLabels MailLabel[] @relation("MailLabels")
  
  // Agenda
  agendaEventsCreated AgendaEvent[] @relation("AgendaEventCreator")
  agendaEventParticipations AgendaEventParticipant[] @relation("AgendaParticipant")
  
  // Messagerie & Listes de diffusion
  mailingListsCreated MailingList[] @relation("MailingListCreator")
  mailingListMemberships MailingListMember[] @relation("MailingListMemberships")
  mailingListMembersAdded MailingListMember[] @relation("MailingListMemberAdder")
  favorites UserFavorite[] @relation("UserFavorites")
  favoritedBy UserFavorite[] @relation("FavoritedBy")
  invitationResponses InvitationResponse[] @relation("InvitationResponses")
  trainingRegistrations TrainingRegistration[] @relation("TrainingRegistrations")
  pollResponses PollResponse[] @relation("PollResponses")
  
  @@unique([tenantId, email])
  @@index([tenantId])
  @@index([email])
  @@index([status])
  @@map("users")
}

enum UserRole {
  SUPER_ADMIN
  ADMIN
  MANAGER
  USER
}

enum UserStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
}

model RefreshToken {
  id        String   @id @default(uuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())
  
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId])
  @@index([token])
  @@map("refresh_tokens")
}

// ================================
// MODULE FMPA
// ================================

model FMPA {
  id          String   @id @default(uuid())
  tenantId    String
  
  // Content
  type        FMPAType
  title       String
  description String?  @db.Text
  
  // Schedule
  startDate   DateTime
  endDate     DateTime
  location    String
  
  // Configuration
  maxParticipants Int?
  requiresApproval Boolean @default(false)
  
  // Pédagogie
  objectives  String?  @db.Text // Objectifs pédagogiques
  equipment   String?  @db.Text // Matériel nécessaire
  
  // Repas
  mealAvailable Boolean @default(false)
  mealOptions Json?    // Options de menu
  
  // Status
  status      FMPAStatus @default(DRAFT)
  
  // QR Code
  qrCode      String?  @unique
  
  // Creator
  createdById String
  
  // Metadata
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  tenant      Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  createdBy   User     @relation("FMPACreator", fields: [createdById], references: [id])
  participations Participation[]
  calendarEvent CalendarEvent?
  ttaEntries TTAEntry[]
  
  @@index([tenantId])
  @@index([status])
  @@index([startDate])
  @@index([type])
  @@map("fmpas")
}

enum FMPAType {
  FORMATION          // Formation théorique ou pratique
  MANOEUVRE          // Manœuvre opérationnelle
  EXERCICE           // Exercice d'entraînement
  PRESENCE_ACTIVE    // Présence active en caserne
  CEREMONIE          // Cérémonie officielle
  REUNION            // Réunion de service
  AUTRE              // Autre type d'activité
}

enum FMPAStatus {
  DRAFT
  PUBLISHED
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

model Participation {
  id          String   @id @default(uuid())
  fmpaId      String
  userId      String
  
  // Status
  status      ParticipationStatus @default(REGISTERED)
  
  // Timestamps
  registeredAt DateTime @default(now())
  confirmedAt  DateTime?
  checkInTime  DateTime?
  checkOutTime DateTime?
  
  // Validation
  validatedBy  String?  // ID du chef qui valide
  validatedAt  DateTime?
  
  // Notes
  notes       String?  @db.Text
  excuseReason String? @db.Text // Raison si absent excusé
  
  // Relations
  fmpa        FMPA     @relation(fields: [fmpaId], references: [id], onDelete: Cascade)
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  mealRegistration FMPAMealRegistration?
  
  @@unique([fmpaId, userId])
  @@index([fmpaId])
  @@index([userId])
  @@index([status])
  @@map("participations")
}

// Inscription repas pour FMPA
model FMPAMealRegistration {
  id              String   @id @default(uuid())
  participationId String   @unique
  participation   Participation @relation(fields: [participationId], references: [id], onDelete: Cascade)
  
  // Choix repas
  menuChoice      String?  // Choix du menu si plusieurs options
  
  // Régimes spéciaux
  dietaryRestrictions String? @db.Text // Allergies, végétarien, etc.
  
  // Confirmation
  confirmed       Boolean  @default(false)
  confirmedAt     DateTime?
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  @@index([participationId])
  @@map("fmpa_meal_registrations")
}

enum ParticipationStatus {
  REGISTERED  // Inscrit
  CONFIRMED   // Confirmé par le chef
  PRESENT     // Présent (pointé)
  ABSENT      // Absent non excusé
  EXCUSED     // Absent excusé
  CANCELLED   // Inscription annulée
}

// ================================
// MODULE MESSAGING
// ================================

model Conversation {
  id          String   @id @default(uuid())
  tenantId    String
  
  // Type
  type        ConversationType @default(DIRECT)
  name        String?  // For group conversations
  avatar      String?
  
  // Metadata
  lastMessageAt DateTime?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  tenant      Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  members     ConversationMember[]
  messages    Message[]
  
  @@index([tenantId])
  @@index([type])
  @@index([lastMessageAt])
  @@map("conversations")
}

enum ConversationType {
  DIRECT
  GROUP
  CHANNEL
}

model ConversationMember {
  id             String   @id @default(uuid())
  conversationId String
  userId         String
  
  // Status
  role           MemberRole @default(MEMBER)
  joinedAt       DateTime @default(now())
  lastReadAt     DateTime?
  
  // Notifications
  notificationsEnabled Boolean @default(true)
  
  // Relations
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([conversationId, userId])
  @@index([conversationId])
  @@index([userId])
  @@map("conversation_members")
}

enum MemberRole {
  OWNER
  ADMIN
  MEMBER
}

model Message {
  id             String   @id @default(uuid())
  conversationId String
  senderId       String
  tenantId       String
  
  // Content
  content        String   @db.Text
  type           MessageType @default(TEXT)
  
  // Attachments
  attachments    Json?    // Array of file metadata
  
  // Status
  status         MessageStatus @default(SENT)
  editedAt       DateTime?
  deletedAt      DateTime?
  
  // Metadata
  createdAt      DateTime @default(now())
  
  // Relations
  tenant         Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender         User     @relation("MessageSender", fields: [senderId], references: [id])
  reads          MessageRead[]
  
  @@index([conversationId])
  @@index([senderId])
  @@index([tenantId])
  @@index([createdAt])
  @@map("messages")
}

enum MessageType {
  TEXT
  IMAGE
  FILE
  SYSTEM
}

enum MessageStatus {
  SENT
  DELIVERED
  READ
  DELETED
}

model MessageRead {
  id        String   @id @default(uuid())
  messageId String
  userId    String
  readAt    DateTime @default(now())
  
  message   Message  @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user      User     @relation("MessageReads", fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([messageId, userId])
  @@index([messageId])
  @@index([userId])
  @@map("message_reads")
}

// ================================
// MODULE FORMATIONS
// ================================

model Formation {
  id          String   @id @default(uuid())
  tenantId    String
  
  // Content
  code        String   // FOR-2025-001
  title       String
  description String?  @db.Text
  
  // Durée et prérequis
  duration    Int?     // en heures
  prerequisites String? @db.Text
  
  // Validité
  validityYears Int?   // Durée de validité (ex: 3 ans)
  
  // Catégorie
  category    FormationCategory @default(AUTRE)
  level       FormationLevel @default(CONTINUE)
  
  // Schedule
  startDate   DateTime
  endDate     DateTime
  location    String
  
  // Configuration
  maxParticipants Int?
  minParticipants Int?
  price       Float?   @default(0)
  
  // Instructor
  instructorId String?
  instructor  User?    @relation("FormationInstructor", fields: [instructorId], references: [id])
  
  // Status
  status      FormationStatus @default(DRAFT)
  
  // Creator
  createdById String
  
  // Metadata
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  tenant      Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  createdBy   User     @relation("FormationCreator", fields: [createdById], references: [id])
  registrations FormationRegistration[]
  
  @@unique([tenantId, code])
  @@index([tenantId])
  @@index([status])
  @@index([startDate])
  @@index([category])
  @@map("formations")
}

enum FormationCategory {
  INCENDIE
  SECOURS
  TECHNIQUE
  MANAGEMENT
  REGLEMENTAIRE
  AUTRE
}

enum FormationLevel {
  INITIALE
  CONTINUE
  PERFECTIONNEMENT
  SPECIALISATION
}

enum FormationStatus {
  DRAFT
  OPEN
  FULL
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

model FormationRegistration {
  id          String   @id @default(uuid())
  formationId String
  userId      String
  tenantId    String
  
  // Status
  status      RegistrationStatus @default(PENDING)
  
  // Validation
  validatedBy String?
  validatedAt DateTime?
  rejectionReason String?
  
  // Présence
  attended    Boolean?
  attendanceRate Float?
  
  // Résultat
  passed      Boolean?
  score       Float?
  certificateUrl String?
  
  // Timestamps
  registeredAt DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  formation   Formation @relation(fields: [formationId], references: [id], onDelete: Cascade)
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  validator   User?    @relation("FormationValidator", fields: [validatedBy], references: [id])
  tenant      Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  
  @@unique([formationId, userId])
  @@index([formationId])
  @@index([userId])
  @@index([tenantId])
  @@index([status])
  @@map("formation_registrations")
}

enum RegistrationStatus {
  PENDING
  APPROVED
  REJECTED
  CANCELLED
  COMPLETED
}

// ================================
// MODULE AGENDA / EVENTS
// ================================

model Event {
  id          String   @id @default(uuid())
  tenantId    String
  
  // Content
  title       String
  description String?  @db.Text
  
  // Schedule
  startDate   DateTime
  endDate     DateTime
  allDay      Boolean  @default(false)
  location    String?
  
  // Type
  type        EventType @default(OTHER)
  color       String?  @default("#3b82f6")
  
  // Creator
  createdById String
  
  // Metadata
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  tenant      Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  createdBy   User     @relation("EventCreator", fields: [createdById], references: [id])
  participations EventParticipation[]
  
  @@index([tenantId])
  @@index([startDate])
  @@index([type])
  @@map("events")
}

enum EventType {
  GUARD_DUTY      // Garde
  TRAINING        // Formation
  MEETING         // Réunion
  INTERVENTION    // Intervention
  OTHER
}

model EventParticipation {
  id          String   @id @default(uuid())
  eventId     String
  userId      String
  
  // Response
  response    ParticipationResponse @default(NO_RESPONSE)
  respondedAt DateTime?
  
  // Relations
  event       Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([eventId, userId])
  @@index([eventId])
  @@index([userId])
  @@map("event_participations")
}

enum ParticipationResponse {
  NO_RESPONSE
  ACCEPTED
  DECLINED
  MAYBE
}

// ================================
// MODULE DOCUMENTS
// ================================

model Document {
  id          String   @id @default(uuid())
  tenantId    String
  
  // Content
  name        String
  description String?  @db.Text
  
  // File
  fileUrl     String
  fileSize    Int      // bytes
  mimeType    String
  
  // Organization
  category    String?
  tags        String[]
  
  // Access
  isPublic    Boolean  @default(false)
  
  // Uploader
  uploadedBy  String
  
  // Metadata
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  tenant      Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  
  @@index([tenantId])
  @@index([category])
  @@map("documents")
}

// ================================
// MODULE NOTIFICATIONS
// ================================

model Notification {
  id          String   @id @default(uuid())
  tenantId    String
  userId      String
  
  // Content
  type        NotificationType
  title       String
  message     String   @db.Text
  icon        String?  // Icône ou emoji
  
  // Link
  linkUrl     String?
  
  // Status
  read        Boolean  @default(false)
  readAt      DateTime?
  
  // Priority & Actions
  priority    NotificationPriority @default(NORMAL)
  actionLabel String?  // Label du bouton d'action
  actionUrl   String?  // URL de l'action
  
  // Push Notification
  pushSent    Boolean  @default(false)
  pushSentAt  DateTime?
  
  // Metadata
  metadata    Json?    // Données supplémentaires
  expiresAt   DateTime? // Date d'expiration
  
  createdAt   DateTime @default(now())
  
  // Relations
  tenant      Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([tenantId])
  @@index([userId])
  @@index([read])
  @@index([createdAt])
  @@index([priority])
  @@index([expiresAt])
  @@map("notifications")
}

enum NotificationType {
  // FMPA
  FMPA_CREATED
  FMPA_UPDATED
  FMPA_CANCELLED
  FMPA_REMINDER
  
  // Chat
  CHAT_MESSAGE
  CHAT_MENTION
  CHAT_REACTION
  CHAT_CHANNEL_INVITE
  
  // Mailbox
  MAIL_RECEIVED
  MAIL_IMPORTANT
  
  // Formation
  FORMATION_APPROVED
  FORMATION_REJECTED
  FORMATION_REMINDER
  
  // Événements
  EVENT_INVITATION
  EVENT_REMINDER
  EVENT_UPDATED
  
  // Messagerie - Invitations
  INVITATION_ACCEPTED
  INVITATION_DECLINED
  INVITATION_TENTATIVE
  
  // Messagerie - Formations
  TRAINING_INVITATION
  TRAINING_REGISTERED
  
  // Messagerie - Sondages
  POLL_CREATED
  POLL_RESPONSE
  POLL_CLOSED
  
  // Système
  SYSTEM
  ANNOUNCEMENT
}

enum NotificationPriority {
  LOW
  NORMAL
  HIGH
  URGENT
}

// ================================
// AUDIT LOG
// ================================

model AuditLog {
  id          String   @id @default(uuid())
  tenantId    String?
  userId      String?
  
  // Action
  action      String   // CREATE_FMPA, UPDATE_USER, etc.
  entity      String   // FMPA, User, etc.
  entityId    String?
  
  // Data
  changes     Json?    // Before/after
  metadata    Json?    // IP, user-agent, etc.
  
  // Timestamp
  createdAt   DateTime @default(now())
  
  @@index([tenantId])
  @@index([userId])
  @@index([action])
  @@index([createdAt])
  @@map("audit_logs")
}

// ================================
// MODULE AGENDA / CALENDRIER
// ================================

model Availability {
  id          String   @id @default(uuid())
  userId      String
  tenantId    String
  
  // Période
  startDate   DateTime
  endDate     DateTime
  
  // Type
  type        AvailabilityType
  reason      String?
  
  // Récurrence
  isRecurring Boolean  @default(false)
  recurrence  Json?    // Pattern de récurrence (ex: tous les lundis)
  
  // Relations
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  tenant      Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([userId])
  @@index([tenantId])
  @@index([startDate, endDate])
  @@map("availabilities")
}

enum AvailabilityType {
  AVAILABLE
  UNAVAILABLE
  PARTIAL
}

model CalendarEvent {
  id          String   @id @default(uuid())
  tenantId    String
  
  // Contenu
  title       String
  description String?  @db.Text
  location    String?
  
  // Dates
  startDate   DateTime
  endDate     DateTime
  allDay      Boolean  @default(false)
  
  // Type et couleur
  type        CalendarEventType
  color       String?  @default("#3b82f6")
  
  // Participants
  participants EventParticipant[]
  
  // Relations optionnelles
  fmpaId      String?  @unique
  fmpa        FMPA?    @relation(fields: [fmpaId], references: [id], onDelete: SetNull)
  
  // Créateur
  createdBy   String
  creator     User     @relation("EventCreator", fields: [createdBy], references: [id])
  
  // Relations
  tenant      Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([tenantId])
  @@index([startDate, endDate])
  @@index([type])
  @@map("calendar_events")
}

enum CalendarEventType {
  FMPA
  FORMATION
  MEETING
  INTERVENTION
  GARDE
  ASTREINTE
  OTHER
}

model EventParticipant {
  id          String   @id @default(uuid())
  eventId     String
  userId      String
  
  status      ParticipantStatus @default(PENDING)
  response    String?  // Message de réponse optionnel
  respondedAt DateTime?
  
  event       CalendarEvent @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@unique([eventId, userId])
  @@index([userId])
  @@index([status])
  @@map("event_participants")
}

enum ParticipantStatus {
  PENDING
  ACCEPTED
  DECLINED
  TENTATIVE
}

// ================================
// MODULE TTA (Temps de Travail Additionnel)
// ================================

model TTAEntry {
  id          String   @id @default(uuid())
  userId      String
  tenantId    String
  
  // Période
  date        DateTime
  month       Int
  year        Int
  
  // Activité
  activityType ActivityType
  fmpaId      String?
  description String?  @db.Text
  
  // Heures
  hours       Float
  nightHours  Float?   @default(0)
  sundayHours Float?   @default(0)
  holidayHours Float?  @default(0)
  
  // Indemnités (calculées)
  baseAmount  Float
  nightBonus  Float?   @default(0)
  sundayBonus Float?   @default(0)
  holidayBonus Float?  @default(0)
  totalAmount Float
  
  // Validation
  status      TTAStatus @default(PENDING)
  validatedBy String?
  validatedAt DateTime?
  rejectionReason String?
  
  // Export
  exportId    String?
  exported    Boolean  @default(false)
  exportedAt  DateTime?
  
  // Relations
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  fmpa        FMPA?    @relation(fields: [fmpaId], references: [id], onDelete: SetNull)
  validator   User?    @relation("TTAValidator", fields: [validatedBy], references: [id])
  export      TTAExport? @relation(fields: [exportId], references: [id])
  tenant      Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([userId])
  @@index([tenantId])
  @@index([month, year])
  @@index([status])
  @@index([date])
  @@map("tta_entries")
}

enum ActivityType {
  FMPA
  INTERVENTION
  FORMATION
  GARDE
  ASTREINTE
  AUTRE
}

enum TTAStatus {
  PENDING
  VALIDATED
  REJECTED
  EXPORTED
}

model TTAExport {
  id          String   @id @default(uuid())
  tenantId    String
  
  // Période
  month       Int
  year        Int
  
  // Export
  format      ExportFormat
  fileUrl     String
  fileName    String
  
  // Stats
  totalEntries Int
  totalAmount Float
  totalUsers  Int
  
  // Créateur
  createdBy   String
  creator     User     @relation(fields: [createdBy], references: [id])
  
  // Entrées
  entries     TTAEntry[]
  
  // Relations
  tenant      Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  
  createdAt   DateTime @default(now())
  
  @@index([tenantId])
  @@index([month, year])
  @@map("tta_exports")
}

enum ExportFormat {
  SEPA_XML
  CSV
  EXCEL
  PDF
}

// ================================
// MODULE PORTAILS & CMS
// ================================

model Portal {
  id          String   @id @default(uuid())
  tenantId    String
  
  // Configuration
  slug        String   // sdis, sap, fdf, etc.
  name        String
  description String?  @db.Text
  icon        String?
  color       String?  @default("#1e40af")
  
  // Visibilité
  isPublic    Boolean  @default(false)
  requiresAuth Boolean @default(true)
  
  // Ordre
  order       Int      @default(0)
  
  // Status
  status      PortalStatus @default(DRAFT)
  
  // Metadata
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  tenant      Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  pages       PortalPage[]
  news        NewsArticle[]
  
  @@unique([tenantId, slug])
  @@index([tenantId])
  @@index([status])
  @@map("portals")
}

enum PortalStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}

model PortalPage {
  id          String   @id @default(uuid())
  portalId    String
  
  // Content
  slug        String
  title       String
  content     String   @db.Text
  excerpt     String?  @db.Text
  
  // SEO
  metaTitle   String?
  metaDescription String?
  
  // Layout
  template    PageTemplate @default(STANDARD)
  order       Int      @default(0)
  
  // Visibilité
  isPublished Boolean  @default(false)
  publishedAt DateTime?
  
  // Metadata
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  portal      Portal   @relation(fields: [portalId], references: [id], onDelete: Cascade)
  
  @@unique([portalId, slug])
  @@index([portalId])
  @@index([isPublished])
  @@map("portal_pages")
}

enum PageTemplate {
  STANDARD
  FULL_WIDTH
  SIDEBAR_LEFT
  SIDEBAR_RIGHT
  LANDING
}

model NewsArticle {
  id          String   @id @default(uuid())
  tenantId    String
  portalId    String?
  
  // Content
  title       String
  slug        String
  content     String   @db.Text
  excerpt     String?  @db.Text
  
  // Media
  coverImage  String?
  images      Json?    // Array of image URLs
  
  // Catégorie
  category    NewsCategory @default(GENERAL)
  tags        String[]
  
  // Auteur
  authorId    String
  
  // Visibilité
  isPublished Boolean  @default(false)
  publishedAt DateTime?
  isPinned    Boolean  @default(false)
  
  // Stats
  viewCount   Int      @default(0)
  
  // Metadata
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  tenant      Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  portal      Portal?  @relation(fields: [portalId], references: [id], onDelete: SetNull)
  author      User     @relation("NewsAuthor", fields: [authorId], references: [id])
  
  @@unique([tenantId, slug])
  @@index([tenantId])
  @@index([portalId])
  @@index([category])
  @@index([isPublished])
  @@index([publishedAt])
  @@map("news_articles")
}

enum NewsCategory {
  GENERAL
  FORMATION
  INTERVENTION
  PREVENTION
  MATERIEL
  EVENEMENT
  ADMINISTRATIF
}

model PortalDocument {
  id          String   @id @default(uuid())
  tenantId    String
  
  // File info
  name        String
  fileName    String
  fileUrl     String
  fileSize    Int      // en bytes
  mimeType    String
  
  // Classification
  category    PortalDocumentCategory
  tags        String[]
  
  // Description
  description String?  @db.Text
  
  // Visibilité
  isPublic    Boolean  @default(false)
  requiresAuth Boolean @default(true)
  
  // Permissions
  allowedRoles String[] // Array of UserRole
  
  // Uploader
  uploadedById String
  
  // Stats
  downloadCount Int    @default(0)
  
  // Metadata
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  tenant      Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  uploadedBy  User     @relation("PortalDocumentUploader", fields: [uploadedById], references: [id])
  
  @@index([tenantId])
  @@index([category])
  @@index([isPublic])
  @@map("portal_documents")
}

enum PortalDocumentCategory {
  PROCEDURE
  FORMATION
  TECHNIQUE
  ADMINISTRATIF
  SECURITE
  MATERIEL
  AUTRE
}

// ================================
// CHAT TEMPS RÉEL
// ================================

// Canaux de discussion
model ChatChannel {
  id          String   @id @default(uuid())
  name        String
  description String?  @db.Text
  type        ChannelType @default(PUBLIC)
  icon        String?  // Emoji ou nom d'icône
  color       String?  // Couleur du canal
  tenantId    String
  createdById String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  archivedAt  DateTime?

  tenant      Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  createdBy   User     @relation("ChannelCreator", fields: [createdById], references: [id])
  
  members     ChatChannelMember[]
  messages    ChatMessage[]
  
  @@index([tenantId])
  @@index([type])
  @@index([createdAt])
  @@map("chat_channels")
}

enum ChannelType {
  PUBLIC      // Visible par tous
  PRIVATE     // Sur invitation
  DIRECT      // Conversation 1-to-1
}

// Membres d'un canal
model ChatChannelMember {
  id          String   @id @default(uuid())
  channelId   String
  userId      String
  role        ChannelRole @default(MEMBER)
  joinedAt    DateTime @default(now())
  lastReadAt  DateTime?
  isMuted     Boolean  @default(false)
  isPinned    Boolean  @default(false)
  
  channel     ChatChannel @relation(fields: [channelId], references: [id], onDelete: Cascade)
  user        User        @relation("ChatMemberships", fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([channelId, userId])
  @@index([userId])
  @@index([lastReadAt])
  @@map("chat_channel_members")
}

enum ChannelRole {
  OWNER
  ADMIN
  MEMBER
}

// Messages du chat
model ChatMessage {
  id          String   @id @default(uuid())
  channelId   String
  userId      String
  content     String   @db.Text
  type        ChatMessageType @default(TEXT)
  parentId    String?  // Pour les threads
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  editedAt    DateTime?
  deletedAt   DateTime?
  
  channel     ChatChannel @relation(fields: [channelId], references: [id], onDelete: Cascade)
  user        User        @relation("ChatMessages", fields: [userId], references: [id])
  parent      ChatMessage? @relation("MessageThread", fields: [parentId], references: [id])
  replies     ChatMessage[] @relation("MessageThread")
  
  reactions   ChatReaction[]
  attachments ChatAttachment[]
  mentions    ChatMention[]
  
  @@index([channelId])
  @@index([userId])
  @@index([parentId])
  @@index([createdAt])
  @@map("chat_messages")
}

enum ChatMessageType {
  TEXT
  IMAGE
  FILE
  SYSTEM  // Messages système (X a rejoint, etc.)
}

// Réactions aux messages
model ChatReaction {
  id        String   @id @default(uuid())
  messageId String
  userId    String
  emoji     String
  createdAt DateTime @default(now())
  
  message   ChatMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user      User        @relation("ChatReactions", fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([messageId, userId, emoji])
  @@index([messageId])
  @@map("chat_reactions")
}

// Pièces jointes du chat
model ChatAttachment {
  id        String   @id @default(uuid())
  messageId String
  fileName  String
  fileUrl   String
  fileSize  Int
  mimeType  String
  createdAt DateTime @default(now())
  
  message   ChatMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)
  
  @@index([messageId])
  @@map("chat_attachments")
}

// Mentions dans les messages
model ChatMention {
  id        String   @id @default(uuid())
  messageId String
  userId    String
  createdAt DateTime @default(now())
  
  message   ChatMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user      User        @relation("ChatMentions", fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([messageId, userId])
  @@index([userId])
  @@map("chat_mentions")
}

// Statut de présence
model UserPresence {
  id        String   @id @default(uuid())
  userId    String   @unique
  status    PresenceStatus @default(OFFLINE)
  customStatus String?
  lastSeen  DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("user_presence")
}

enum PresenceStatus {
  ONLINE
  AWAY
  BUSY
  OFFLINE
}

// ================================
// MAILBOX (EMAIL INTERNE)
// ================================

// Messages email internes
model MailMessage {
  id          String   @id @default(uuid())
  subject     String
  body        String   @db.Text
  fromId      String
  tenantId    String
  isDraft     Boolean  @default(false)
  isImportant Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  tenant      Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  from        User     @relation("SentMails", fields: [fromId], references: [id])
  
  recipients  MailRecipient[]
  attachments MailAttachment[]
  labels      MailLabel[]
  mailingLists MailingList[] @relation("MailingListMessages")
  eventInvitation MessageEventInvitation?
  trainingProposal MessageTrainingProposal?
  poll        MessagePoll?
  
  @@index([tenantId])
  @@index([fromId])
  @@index([createdAt])
  @@index([isDraft])
  @@map("mail_messages")
}

// Destinataires des emails
model MailRecipient {
  id        String   @id @default(uuid())
  messageId String
  userId    String
  type      RecipientType
  isRead    Boolean  @default(false)
  readAt    DateTime?
  folder    MailFolder @default(INBOX)
  isArchived Boolean @default(false)
  isStarred Boolean  @default(false)
  deletedAt DateTime?
  
  message   MailMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user      User        @relation("ReceivedMails", fields: [userId], references: [id])
  
  @@unique([messageId, userId, type])
  @@index([userId])
  @@index([folder])
  @@index([isRead])
  @@map("mail_recipients")
}

enum RecipientType {
  TO
  CC
  BCC
}

enum MailFolder {
  INBOX
  SENT
  DRAFTS
  ARCHIVE
  TRASH
}

// Pièces jointes email
model MailAttachment {
  id        String   @id @default(uuid())
  messageId String
  fileName  String
  fileUrl   String
  fileSize  Int
  mimeType  String
  createdAt DateTime @default(now())
  
  message   MailMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)
  
  @@index([messageId])
  @@map("mail_attachments")
}

// Labels/Tags pour emails
model MailLabel {
  id        String   @id @default(uuid())
  messageId String
  userId    String
  name      String
  color     String
  
  message   MailMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user      User        @relation("MailLabels", fields: [userId], references: [id])
  
  @@unique([messageId, userId, name])
  @@index([userId])
  @@map("mail_labels")
}

// ================================
// AGENDA / CALENDAR MODELS
// ================================

// Événements du calendrier
model AgendaEvent {
  id          String   @id @default(uuid())
  title       String
  description String?  @db.Text
  startDate   DateTime
  endDate     DateTime
  allDay      Boolean  @default(false)
  
  type        AgendaEventType @default(AUTRE)
  status      AgendaEventStatus @default(SCHEDULED)
  
  location    String?
  color       String?  // Couleur dans le calendrier
  
  // Relations
  createdById String
  createdBy   User     @relation("AgendaEventCreator", fields: [createdById], references: [id])
  
  tenantId    String
  tenant      Tenant   @relation("AgendaEvents", fields: [tenantId], references: [id], onDelete: Cascade)
  
  participants AgendaEventParticipant[]
  reminders    AgendaEventReminder[]
  messageInvitations MessageEventInvitation[] @relation("MessageInvitations")
  
  // Récurrence
  isRecurring Boolean  @default(false)
  recurrenceRule String? // RRULE format (RFC 5545)
  parentEventId String?
  parentEvent   AgendaEvent?  @relation("RecurringEvents", fields: [parentEventId], references: [id], onDelete: SetNull)
  childEvents   AgendaEvent[] @relation("RecurringEvents")
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([tenantId, startDate])
  @@index([type])
  @@index([status])
  @@index([createdById])
  @@map("agenda_events")
}

// Participants aux événements
model AgendaEventParticipant {
  id        String   @id @default(uuid())
  eventId   String
  event     AgendaEvent @relation(fields: [eventId], references: [id], onDelete: Cascade)
  userId    String
  user      User     @relation("AgendaParticipant", fields: [userId], references: [id])
  
  status    ParticipantStatus @default(PENDING)
  role      String?  // CHEF, EQUIPIER, OBSERVATEUR
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@unique([eventId, userId])
  @@index([userId])
  @@map("agenda_event_participants")
}

// Rappels pour événements
model AgendaEventReminder {
  id        String   @id @default(uuid())
  eventId   String
  event     AgendaEvent @relation(fields: [eventId], references: [id], onDelete: Cascade)
  
  type      ReminderType // EMAIL, NOTIFICATION, SMS
  timing    Int      // Minutes avant l'événement
  sent      Boolean  @default(false)
  sentAt    DateTime?
  
  createdAt DateTime @default(now())
  
  @@index([eventId])
  @@index([sent])
  @@map("agenda_event_reminders")
}

// Enums pour l'Agenda
enum AgendaEventType {
  GARDE
  FMPA
  FORMATION
  PROTOCOLE
  ENTRETIEN
  PERSONNEL
  REUNION
  AUTRE
}

enum AgendaEventStatus {
  SCHEDULED
  CONFIRMED
  CANCELLED
  COMPLETED
}

enum ReminderType {
  EMAIL
  NOTIFICATION
  SMS
}

// ================================
// MESSAGERIE & ANNUAIRE RH
// ================================

// Liste de diffusion
model MailingList {
  id          String   @id @default(uuid())
  tenantId    String
  tenant      Tenant   @relation("MailingLists", fields: [tenantId], references: [id], onDelete: Cascade)
  
  name        String   // "Équipe A", "Tous les chefs"
  description String?
  type        MailingListType @default(STATIC) // STATIC ou DYNAMIC
  
  // Pour listes dynamiques
  criteria    Json?    // Critères de sélection automatique
  
  // Permissions
  createdById String
  createdBy   User     @relation("MailingListCreator", fields: [createdById], references: [id])
  isPublic    Boolean  @default(false) // Visible par tous ou privée
  
  // Metadata
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  // Relations
  members     MailingListMember[]
  messages    MailMessage[] @relation("MailingListMessages")
  
  @@index([tenantId])
  @@index([createdById])
  @@map("mailing_lists")
}

// Membres d'une liste de diffusion (pour listes statiques)
model MailingListMember {
  id        String   @id @default(uuid())
  listId    String
  list      MailingList @relation(fields: [listId], references: [id], onDelete: Cascade)
  
  userId    String
  user      User     @relation("MailingListMemberships", fields: [userId], references: [id], onDelete: Cascade)
  
  addedById String
  addedBy   User     @relation("MailingListMemberAdder", fields: [addedById], references: [id])
  
  addedAt   DateTime @default(now())
  
  @@unique([listId, userId])
  @@index([listId])
  @@index([userId])
  @@map("mailing_list_members")
}

// Favoris utilisateur (contacts favoris)
model UserFavorite {
  id          String   @id @default(uuid())
  userId      String
  user        User     @relation("UserFavorites", fields: [userId], references: [id], onDelete: Cascade)
  
  favoriteId  String
  favorite    User     @relation("FavoritedBy", fields: [favoriteId], references: [id], onDelete: Cascade)
  
  createdAt   DateTime @default(now())
  
  @@unique([userId, favoriteId])
  @@index([userId])
  @@map("user_favorites")
}

// Invitation événement dans message
model MessageEventInvitation {
  id          String   @id @default(uuid())
  messageId   String
  message     MailMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)
  
  eventId     String
  event       AgendaEvent @relation("MessageInvitations", fields: [eventId], references: [id], onDelete: Cascade)
  
  // Réponses des destinataires
  responses   InvitationResponse[]
  
  createdAt   DateTime @default(now())
  
  @@unique([messageId])
  @@index([eventId])
  @@map("message_event_invitations")
}

// Réponse à une invitation
model InvitationResponse {
  id           String   @id @default(uuid())
  invitationId String
  invitation   MessageEventInvitation @relation(fields: [invitationId], references: [id], onDelete: Cascade)
  
  userId       String
  user         User     @relation("InvitationResponses", fields: [userId], references: [id], onDelete: Cascade)
  
  status       InvitationStatus
  message      String?  // Message optionnel de l'utilisateur
  
  respondedAt  DateTime @default(now())
  
  @@unique([invitationId, userId])
  @@index([invitationId])
  @@index([userId])
  @@map("invitation_responses")
}

// Proposition inscription formation dans message
model MessageTrainingProposal {
  id          String   @id @default(uuid())
  messageId   String
  message     MailMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)
  
  title       String
  description String?  @db.Text
  startDate   DateTime
  endDate     DateTime
  location    String?
  maxParticipants Int?
  
  // Inscriptions
  registrations TrainingRegistration[]
  
  createdAt   DateTime @default(now())
  
  @@unique([messageId])
  @@map("message_training_proposals")
}

// Inscription à une formation proposée
model TrainingRegistration {
  id          String   @id @default(uuid())
  proposalId  String
  proposal    MessageTrainingProposal @relation(fields: [proposalId], references: [id], onDelete: Cascade)
  
  userId      String
  user        User     @relation("TrainingRegistrations", fields: [userId], references: [id], onDelete: Cascade)
  
  status      TrainingRegistrationStatus @default(PENDING)
  message     String?  // Message optionnel
  
  registeredAt DateTime @default(now())
  
  @@unique([proposalId, userId])
  @@index([proposalId])
  @@index([userId])
  @@map("training_registrations")
}

// Sondage dans message
model MessagePoll {
  id          String   @id @default(uuid())
  messageId   String
  message     MailMessage @relation(fields: [messageId], references: [id], onDelete: Cascade)
  
  question    String
  description String?  @db.Text
  
  // Options
  options     PollOption[]
  
  // Configuration
  multipleChoice Boolean @default(false) // Autoriser plusieurs réponses
  anonymous   Boolean  @default(false)   // Réponses anonymes
  
  // Dates
  closesAt    DateTime?
  closed      Boolean  @default(false)
  
  createdAt   DateTime @default(now())
  
  @@unique([messageId])
  @@map("message_polls")
}

// Option de sondage
model PollOption {
  id          String   @id @default(uuid())
  pollId      String
  poll        MessagePoll @relation(fields: [pollId], references: [id], onDelete: Cascade)
  
  text        String
  order       Int      @default(0)
  
  // Réponses
  responses   PollResponse[]
  
  createdAt   DateTime @default(now())
  
  @@index([pollId])
  @@map("poll_options")
}

// Réponse à un sondage
model PollResponse {
  id          String   @id @default(uuid())
  optionId    String
  option      PollOption @relation(fields: [optionId], references: [id], onDelete: Cascade)
  
  userId      String
  user        User     @relation("PollResponses", fields: [userId], references: [id], onDelete: Cascade)
  
  respondedAt DateTime @default(now())
  
  @@unique([optionId, userId])
  @@index([optionId])
  @@index([userId])
  @@map("poll_responses")
}

// Enums pour la messagerie
enum MailingListType {
  STATIC   // Membres ajoutés manuellement
  DYNAMIC  // Membres basés sur critères
}

enum InvitationStatus {
  ACCEPTED
  DECLINED
  TENTATIVE
}

enum TrainingRegistrationStatus {
  PENDING
  CONFIRMED
  CANCELLED
  WAITLIST
}

